import { Result } from "./Result.js";

type SomeVariant<T> = { readonly isPresent: true; value: T }
type NoneVariant = { readonly isPresent: false }
type OptionVariantsUnion<T> = SomeVariant<T> | NoneVariant

export class Option<T> {
    readonly _: OptionVariantsUnion<T>

    private constructor(state: OptionVariantsUnion<T>) {
        this._ = state
    }

    static some<T>(value: T): Option<T> {
        return new Option({ isPresent: true, value })
    }

    static none<T>(): Option<T> {
        return new Option({ isPresent: false })
    }

    static of<T>(input: T | null | undefined): Option<T> {
        if (input === null || input === undefined) {
            return Option.none()
        }
        return Option.some(input)
    }

    toResult = <T,>(option: SomeVariant<T>): Result<T> =>
        Result.ok(option.value)

    orElse<E>(fallback: E): T | E {
        return this._.isPresent ? this._.value : fallback
    }

    toString(): T | undefined {
        return this._.isPresent ? this._.value : undefined
    }

    toJSON() {
        return this._.isPresent ? this._.value : undefined
    }
}



import { Options, type Option } from "./Option.js"

type OkVariant<T> = { readonly isValid: true; value: T }
type ErrVariant = { readonly isValid: false; error: string }
export type Result<T> = OkVariant<T> | ErrVariant
export type NilResult = Result<null>

const ok = <T,>(value: T): Result<T> => ({
    isValid: true,
    value: value,
})

const err = <T,>(error: string): Result<T> => ({
    isValid: false,
    error: error,
})

// eslint-disable-next-line no-unused-vars
function wrap(result: ErrVariant, fn: (e: string) => string): ErrVariant {
    result.error = fn(result.error)
    return result
}

function nil(): NilResult {
    return Result.ok(null)
}

function toOption<T>(result: Result<T>): Option<T> {
    if (result._.isValid) {
        return Option.some(result.value)
    }
    return Option.none()
}

function of<T>(fn: () => T): Result<T> {
    try {
        const result = fn()
        if (typeof result === "number" && isNaN(result)) {
            return Result.err("invalid number")
        }
        return Result.ok(result)
    } catch (ex) {
        if (ex instanceof Error) {
            return Result.err(ex.message)
        }

        // eslint-disable-next-line no-console
        console.error(ex)
        return Result.err("unknown error occurred")
    }
}

async function ofPromise<T>(promise: Promise<T>): Promise<Result<T>> {
    try {
        const result = await promise
        if (typeof result === "number" && isNaN(result)) {
            return Result.err("invalid number")
        }
        return Result.ok(result)
    } catch (ex) {
        if (ex instanceof Error) {
            return Result.err(ex.message)
        }

        // eslint-disable-next-line no-console
        console.error(ex)
        return Result.err("unknown error occurred")
    }
}

export const Results = {
    ok,
    err,
    wrap,
    nil,
    toOption,
    of,
    ofPromise,
}
